//! Type-safe bindings for SSkirmishAICallback.
//!
//! The struct is generated by bindgen from the engine's SSkirmishAICallback.h.
//! Each field is an `Option<unsafe extern "C" fn(...)>` — accessed by name,
//! never by manual index.

// Include the bindgen-generated struct
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals, dead_code, unused_unsafe)]
mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
pub use bindings::SSkirmishAICallback;

use std::ffi::{c_char, c_float, c_int, c_void, CStr, CString};
use std::os::raw::c_short;

/// Safe wrapper around the raw callback pointer table.
pub struct EngineCallbacks {
    pub(crate) ai_id: c_int,
    raw: *const SSkirmishAICallback,
}

// SAFETY: The callback pointer table is valid for the AI's entire lifetime
// (between init() and release()). The engine owns the memory.
unsafe impl Send for EngineCallbacks {}

/// Helper: call an `Option<fn>`, unwrapping the function pointer.
macro_rules! call {
    ($self:expr, $field:ident $(, $arg:expr)*) => {
        unsafe {
            ((*$self.raw).$field.unwrap())($($arg),*)
        }
    };
}

impl EngineCallbacks {
    /// # Safety
    /// `raw` must be a valid, non-null pointer that remains valid until release().
    pub unsafe fn new(ai_id: c_int, raw: *const SSkirmishAICallback) -> Self {
        Self { ai_id, raw }
    }

    // ── Game state ──

    pub fn get_current_frame(&self) -> i32 {
        call!(self, Game_getCurrentFrame, self.ai_id)
    }

    pub fn get_my_team(&self) -> i32 {
        call!(self, Game_getMyTeam, self.ai_id)
    }

    pub fn get_my_ally_team(&self) -> i32 {
        call!(self, Game_getMyAllyTeam, self.ai_id)
    }

    pub fn is_paused(&self) -> bool {
        call!(self, Game_isPaused, self.ai_id)
    }

    // ── Economy ──

    pub fn economy_current(&self, resource_id: i32) -> f32 {
        call!(self, Economy_getCurrent, self.ai_id, resource_id)
    }

    pub fn economy_income(&self, resource_id: i32) -> f32 {
        call!(self, Economy_getIncome, self.ai_id, resource_id)
    }

    pub fn economy_usage(&self, resource_id: i32) -> f32 {
        call!(self, Economy_getUsage, self.ai_id, resource_id)
    }

    pub fn economy_storage(&self, resource_id: i32) -> f32 {
        call!(self, Economy_getStorage, self.ai_id, resource_id)
    }

    // ── Unit queries ──

    /// Resolve a unit definition name (e.g. "cloakraid") to its numeric ID.
    pub fn get_unit_def_by_name(&self, name: &str) -> Option<i32> {
        let c_name = CString::new(name).ok()?;
        let id = call!(self, getUnitDefByName, self.ai_id, c_name.as_ptr());
        if id < 0 { None } else { Some(id) }
    }

    /// Get the unit definition ID for a given unit instance.
    pub fn unit_get_def(&self, unit_id: i32) -> i32 {
        call!(self, Unit_getDef, self.ai_id, unit_id)
    }

    /// Get the internal name of a unit definition (e.g. "cloakraid").
    pub fn unit_def_get_name(&self, unit_def_id: i32) -> Option<String> {
        let ptr = call!(self, UnitDef_getName, self.ai_id, unit_def_id);
        if ptr.is_null() {
            None
        } else {
            Some(unsafe { CStr::from_ptr(ptr) }.to_string_lossy().into_owned())
        }
    }

    /// Get the human-readable name of a unit definition (e.g. "Glaive").
    pub fn unit_def_get_human_name(&self, unit_def_id: i32) -> Option<String> {
        let ptr = call!(self, UnitDef_getHumanName, self.ai_id, unit_def_id);
        if ptr.is_null() {
            None
        } else {
            Some(unsafe { CStr::from_ptr(ptr) }.to_string_lossy().into_owned())
        }
    }

    // ── Map ──

    pub fn map_width(&self) -> i32 {
        call!(self, Map_getWidth, self.ai_id)
    }

    pub fn map_height(&self) -> i32 {
        call!(self, Map_getHeight, self.ai_id)
    }

    /// Check if a building can be placed at a given position.
    pub fn map_can_build_at(&self, unit_def_id: i32, pos: &[f32; 3], facing: i32) -> bool {
        let mut pos_copy = *pos;
        call!(
            self,
            Map_isPossibleToBuildAt,
            self.ai_id,
            unit_def_id,
            pos_copy.as_mut_ptr(),
            facing
        )
    }

    /// Find the closest valid build position near the given coordinates.
    /// Returns None if no valid position found (engine returns {-1, 0, 0}).
    pub fn map_find_closest_build_site(
        &self,
        unit_def_id: i32,
        pos: &[f32; 3],
        search_radius: f32,
        min_dist: i32,
        facing: i32,
    ) -> Option<[f32; 3]> {
        let mut pos_copy = *pos;
        let mut result = [0.0f32; 3];
        call!(
            self,
            Map_findClosestBuildSite,
            self.ai_id,
            unit_def_id,
            pos_copy.as_mut_ptr(),
            search_radius,
            min_dist,
            facing,
            result.as_mut_ptr()
        );
        // Engine returns {-1, 0, 0} if no valid position found
        if result[0] < 0.0 {
            None
        } else {
            Some(result)
        }
    }

    // ── GameRulesParams ──

    pub fn game_rules_param_float(&self, name: &str, default: f32) -> f32 {
        let c_name = CString::new(name).ok().unwrap();
        call!(self, Game_getRulesParamFloat, self.ai_id, c_name.as_ptr(), default)
    }

    /// Query ZK metal spot positions from GameRulesParams.
    /// Returns vec of (x, y, z, metal) tuples.
    pub fn get_metal_spots(&self) -> Vec<(f32, f32, f32, f32)> {
        let count = self.game_rules_param_float("mex_count", 0.0) as i32;
        if count <= 0 {
            return Vec::new();
        }
        let mut spots = Vec::with_capacity(count as usize);
        for i in 1..=count {
            let x = self.game_rules_param_float(&format!("mex_x{}", i), 0.0);
            let y = self.game_rules_param_float(&format!("mex_y{}", i), 0.0);
            let z = self.game_rules_param_float(&format!("mex_z{}", i), 0.0);
            let metal = self.game_rules_param_float(&format!("mex_metal{}", i), 0.0);
            spots.push((x, y, z, metal));
        }
        spots
    }

    // ── Logging ──

    pub fn log(&self, msg: &str) {
        if let Ok(c_msg) = CString::new(msg) {
            call!(self, Log_log, self.ai_id, c_msg.as_ptr());
        }
    }

    // ── Commands ──

    pub fn handle_command(
        &self,
        command_topic: c_int,
        command_data: *mut c_void,
    ) -> c_int {
        // commandId must be -1 to use NETMSG_AICOMMAND (14).
        // Any other value triggers NETMSG_AICOMMAND_TRACKED (76)
        // which this engine version's server does not handle.
        call!(
            self,
            Engine_handleCommand,
            self.ai_id,
            COMMAND_TO_ID_ENGINE,
            -1 as c_int,
            command_topic,
            command_data
        )
    }

    // ── AI info / options ──

    pub fn get_info_value(&self, key: &str) -> Option<String> {
        let c_key = CString::new(key).ok()?;
        let ptr = call!(
            self,
            SkirmishAI_Info_getValueByKey,
            self.ai_id,
            c_key.as_ptr()
        );
        if ptr.is_null() {
            None
        } else {
            Some(unsafe { CStr::from_ptr(ptr) }.to_string_lossy().into_owned())
        }
    }

    pub fn get_option_value(&self, key: &str) -> Option<String> {
        let c_key = CString::new(key).ok()?;
        let ptr = call!(
            self,
            SkirmishAI_OptionValues_getValueByKey,
            self.ai_id,
            c_key.as_ptr()
        );
        if ptr.is_null() {
            None
        } else {
            Some(unsafe { CStr::from_ptr(ptr) }.to_string_lossy().into_owned())
        }
    }
}

// ── Constants ──

pub const COMMAND_TO_ID_ENGINE: c_int = -1;

// Engine-level command topics (from AISCommands.h CommandTopic enum)
pub const COMMAND_SEND_TEXT_MESSAGE: c_int = 6;
pub const COMMAND_PAUSE: c_int = 81;
pub const COMMAND_UNIT_BUILD: c_int = 35;
pub const COMMAND_UNIT_STOP: c_int = 36;
pub const COMMAND_UNIT_MOVE: c_int = 42;
pub const COMMAND_UNIT_PATROL: c_int = 43;
pub const COMMAND_UNIT_FIGHT: c_int = 44;
pub const COMMAND_UNIT_ATTACK: c_int = 45;
pub const COMMAND_UNIT_ATTACK_AREA: c_int = 46;
pub const COMMAND_UNIT_GUARD: c_int = 47;
pub const COMMAND_UNIT_REPAIR: c_int = 51;
pub const COMMAND_UNIT_SET_FIRE_STATE: c_int = 52;
pub const COMMAND_UNIT_SET_MOVE_STATE: c_int = 53;
pub const COMMAND_UNIT_RECLAIM_UNIT: c_int = 63;
pub const COMMAND_UNIT_RECLAIM_AREA: c_int = 64;

// Command option flags
pub const UNIT_COMMAND_OPTION_SHIFT_KEY: c_short = 1 << 5;

// ── Command data structs ──

#[repr(C)]
pub struct SMoveUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_pos: *mut [c_float; 3],
}

#[repr(C)]
pub struct SStopUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
}

#[repr(C)]
pub struct SAttackUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_attack_unit_id: c_int,
}

#[repr(C)]
pub struct SBuildUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_build_unit_def_id: c_int,
    pub build_pos: *mut [c_float; 3],
    pub facing: c_int,
}

#[repr(C)]
pub struct SPatrolUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_pos: *mut [c_float; 3],
}

#[repr(C)]
pub struct SFightUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_pos: *mut [c_float; 3],
}

#[repr(C)]
pub struct SGuardUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_guard_unit_id: c_int,
}

#[repr(C)]
pub struct SRepairUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub to_repair_unit_id: c_int,
}

#[repr(C)]
pub struct SSendTextMessageCommand {
    pub text: *const c_char,
    pub zone: c_int,
}

#[repr(C)]
pub struct SSetFireStateUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub fire_state: c_int,
}

#[repr(C)]
pub struct SSetMoveStateUnitCommand {
    pub unit_id: c_int,
    pub group_id: c_int,
    pub options: c_short,
    pub time_out: c_int,
    pub move_state: c_int,
}

#[repr(C)]
pub struct SPauseCommand {
    pub enable: bool,
    /// Reason for the (un-)pause, or null.
    pub reason: *const c_char,
}
